<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - shader [Monjori]</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
    body {
        color: #ffffff;
        font-family: Monospace;
        font-size: 13px;
        text-align: center;
        font-weight: bold;
        background-color: #000000;
        margin: 0px;
        overflow: hidden;
    }
    
    #info {
        position: absolute;
        top: 0px;
        width: 100%;
        padding: 5px;
    }
    
    a {
        color: #ffffff;
    }
    
    #oldie a {
        color: #da0
    }
    </style>
</head>

<body>
    <div id="container"></div>
    <script src="js/three.min.js"></script>
    <script src="js/Detector.js"></script>
    <script src="js/stats.min.js"></script>
    <script src='//code.jquery.com/jquery-1.7.2.min.js'></script>
    <script src='//localhost:3000/socket.io/socket.io.js'></script>
    <script id="vertexShader" type="x-shader/x-vertex">
        void main() { gl_Position = vec4( position, 1.0 ); }
    </script>

<script id="fragmentShader" type="x-shader/x-fragment">




#ifdef GL_ES
precision mediump float;
#endif

#extension GL_OES_standard_derivatives : enable

uniform float time;
uniform vec2 mouse;
uniform vec2 resolution;
uniform float incoming;


#define OCTAVES 5

// Squish and strech the tunnel
#define STRETCH 10.0
#define SQUISH 3.0

// Everthing should be a tunnel :)
// From http://glsl.heroku.com/e#11554.0

float rand(vec2 n) { 
    return fract(sin(dot(n, vec2(13, 5))) * 43758.5453);
}

float noise(vec2 n) {
    const vec2 d = vec2(0.0, 1.0);
    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));
    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);
}

float fbm(vec2 n) {
    float total = 0.0, amplitude = 1.0;
    for (int i = 0; i < OCTAVES; i++) {
        total += noise(n) * amplitude;
        n += n;
        amplitude *= incoming;
    }
    return total;
}

vec3 tex(vec2 pos) {
    const vec3 c1 = vec3(1,2,4);
    const vec3 c2 = vec3(2,0.9,1);
    const vec3 c3 = vec3(0);
    const vec3 c4 = vec3(0,0.1,0);
    const vec3 c5 = vec3(.1);
    const vec3 c6 = vec3(1.2);
    vec2 p = pos;
    float q = fbm(p - time * incoming);
    vec2 r = vec2(fbm(p + q + time - p.x - p.y), fbm(p + q + time));
    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);
    return c;
}




void main(void) {

    vec2 p = (gl_FragCoord.xy / resolution - vec2(.7)) * vec2(resolution.x/resolution.y, 1.);


    float r = length(p);
    float a = atan(p.y, p.x);

    vec2 uv = vec2(sin(a), cos(a))/pow(r, 1.+.1)+time*.001;
    
    vec3 col = tex(uv);
    gl_FragColor = vec4(col*length(p),1);

}

</script>
    <script>
    var incoming;

    //Websocket Stuff
    var socket = io.connect('//localhost:3000');
        socket.on('data', function(data) {
                console.log(data);
                incoming = map_range(data,0,1023,-1,1)
            });
        socket.on('error', function() { console.error(arguments) });
        socket.on('message', function() { console.log(arguments) });



    if (!Detector.webgl) Detector.addGetWebGLMessage();

    var container, stats;
    var camera, scene, renderer;
    var uniforms;
    init();
    animate();

function map_range(value, low1, high1, low2, high2) {
    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);
}

    function init() {

        container = document.getElementById('container');

        camera = new THREE.Camera();
        camera.position.z = 1;

        scene = new THREE.Scene();

        var geometry = new THREE.PlaneBufferGeometry(2, 2);

        uniforms = {
            time: {
                type: "f",
                value: 1.0
            },
            incoming: {
                type: "f",
                value: 0.1
            },
            resolution: {
                type: "v2",
                value: new THREE.Vector2()
            }
        };

        var material = new THREE.ShaderMaterial({

            uniforms: uniforms,
            vertexShader: document.getElementById('vertexShader').textContent,
            fragmentShader: document.getElementById('fragmentShader').textContent

        });

        var mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        renderer = new THREE.WebGLRenderer();
        // renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        stats = new Stats();
        stats.domElement.style.position = 'absolute';
        stats.domElement.style.top = '0px';
        container.appendChild(stats.domElement);

        onWindowResize();

        window.addEventListener('resize', onWindowResize, false);

    }

    function onWindowResize(event) {

        renderer.setSize(window.innerWidth, window.innerHeight);
        uniforms.resolution.value.x = renderer.domElement.width;
        uniforms.resolution.value.y = renderer.domElement.height;

    }

    //

    function animate() {
        requestAnimationFrame(animate);
        render();
        stats.update();
    }

    function render() {
        uniforms.time.value += 0.05;
        uniforms.incoming.value = incoming;
        renderer.render(scene, camera);
    }
    </script>
</body>

</html>
